export declare type Opt<T> = T | null | undefined;
export declare function notnull<T>(v: T, v1: T, v2?: T): Opt<T>;
export declare function defined<T>(v: T, v1: T, v2?: T): Opt<T>;
export declare function maybe<T, R>(v: T | undefined | null, func: (vv: T) => R): Opt<R>;
export declare const NotNull: (v: any) => boolean;
export declare const Defined: (v: any) => boolean;
export declare const Truly: (v: any) => boolean;
export declare function HostNull<T>(_v: any, k: keyof T, t: T): boolean;
export declare function HostUndefined<T>(_v: any, k: keyof T, t: T): boolean;
export declare function NotIn<T>(_v: any, k: keyof T, t: T): boolean;
export declare type VK<T, R, K extends keyof T = keyof T> = (v: T[K], k: keyof T, t: T) => R;
export declare type Few<T> = T | T[];
export declare function forEach<T extends object>(func: VK<T, void>, source: T): void;
export declare function assignFieldsWhen<T extends object>(fields: (keyof T)[] | true, filter: VK<T, boolean> | true, target: T, sourceS: Few<Partial<T>>): T;
export declare function assignFields<T extends object>(fields: (keyof T)[], target: T, sources: Few<Partial<T>>): T;
export declare function assignWhen<T extends object>(filter: VK<T, boolean> | true, target: T, sources: Few<Partial<T>>): T;
export declare function assign<T extends object>(target: T, ...sources: Partial<T>[]): T;
export declare function boolean(v: unknown, d?: Opt<boolean>): Opt<boolean>;
export declare function number(v: unknown, d?: Opt<number>): Opt<number>;
export declare function string(v: unknown, d?: Opt<string>): Opt<string>;
declare type PossibleKeys<T> = {
    [K in keyof T]: T[K] extends string | number ? K : never;
}[keyof T];
declare type OptKey = Opt<string | number>;
export declare function mergeByKeyWhen<T extends object>(filter: VK<T, boolean> | true, mergeKey: PossibleKeys<T> | ((o: T) => OptKey), ...sources: T[][]): T[];
export declare function mergeByKey<T extends object>(mergeKey: PossibleKeys<T> | ((o: T) => OptKey), ...sources: T[][]): T[];
export declare function uniqueKey<T extends object>(f: (o: T) => OptKey): (o: T) => string | number;
export declare type Schema<T> = {
    [P in keyof T]: Schema<T[P]> | (T[P] extends object ? never : (v: any) => Opt<T[P]>);
};
export declare function copyWithSchema<T>(schema: Schema<T>, data: object): T;
export declare function withDefault<T>(p: (v: any, d?: T | null) => Opt<T>, d: T | null): (v: any) => T | null | undefined;
export {};
