export declare function notnull<T>(v: T, v1: T, v2?: T): T | null | undefined;
export declare function defined<T>(v: T, v1: T, v2?: T): T | null | undefined;
export declare function maybe<T, R>(v: T | undefined | null, func: (vv: T) => R): R | undefined | null;
export declare const NotNull: (v: any) => boolean;
export declare const Defined: (v: any) => boolean;
export declare const Truly: (v: any) => boolean;
export declare function HostNull<T>(_v: any, k: keyof T, t: T): boolean;
export declare function HostUndefined<T>(_v: any, k: keyof T, t: T): boolean;
export declare function NotIn<T>(_v: any, k: keyof T, t: T): boolean;
export declare type VK<T, R, K extends keyof T = keyof T> = (v: T[K], k: keyof T, t: T) => R;
export declare type Few<T> = T | T[];
export declare function forEach<T extends object>(func: VK<T, void>, source: T): void;
export declare function assignFieldsWhen<T extends object>(fields: (keyof T)[] | true, filter: VK<T, boolean> | true, target: T, sourceS: Few<Partial<T>>): T;
export declare function assignFields<T extends object>(fields: (keyof T)[], target: T, sources: Few<Partial<T>>): T;
export declare function assignWhen<T extends object>(filter: VK<T, boolean> | true, target: T, sources: Few<Partial<T>>): T;
export declare function assign<T extends object>(target: T, ...sources: Partial<T>[]): T;
export declare function boolean(v: unknown, d?: boolean | null | undefined): boolean | null | undefined;
export declare function number(v: unknown, d?: number | null | undefined): number | null | undefined;
export declare function string(v: unknown, d?: string | null | undefined): string | null | undefined;
declare type PossibleKeys<T> = {
    [K in keyof T]: T[K] extends string | number ? K : never;
}[keyof T];
export declare function mergeByKeyWhen<T extends object>(filter: VK<T, boolean> | true, mergeKey: PossibleKeys<T> | ((o: T) => string | number), ...sources: T[][]): T[];
export declare function mergeByKey<T extends object>(mergeKey: PossibleKeys<T> | ((o: T) => string | number), ...sources: T[][]): T[];
export declare function uniqueKey<T extends object>(f: (o: T) => string | number | null | undefined): (o: T) => string | number;
export declare type Schema<T> = {
    [P in keyof T]: Schema<T[P]> | (T[P] extends object ? never : (v: any) => T[P] | null | undefined);
};
export declare function copyWithSchema<T>(schema: Schema<T>, data: object): T;
export declare function withDefault<T>(p: (v: any, d?: T | null) => T | null | undefined, d: T | null): (v: any) => T | null | undefined;
export {};
